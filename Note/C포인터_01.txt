주소연산자 &
	주소 출력
		int num = 10;
		printf("%p\n", (void*)&num);
	보통 주소를 보여줄 때는 16진수를 사용
	%p는 주소를 16진수로 보여줌
	실행할 때마다 주소가 달라질 수 있음
		요즘 운영체제에서는 보안 강화를 위해 실행할 때마다 주소를 바꿔 줌(ASLR)
포인터
	주소를 저장하기 위한 변수형
	변수인데 속에 담긴 내용은 메모리 주소
	포인터 변수를 선언할 때는 그 주소에 어떤 형의 데이터가 있는지 명시하기 위해 포인터 앞에 자료형을 붙임(사이에 붙여도 됨 근데 자료형 뒤에 붙이는게 좋음)
	참조
		포인터가 이미 하고 있는 일
		값이 어디에 있는지 가리키고 있는 것
	역 참조
		주소로 직접 가서 거기 저장되어 있는 값에 접근하는 것
		참조의 반대라 역 참조
	역 참조 연산자*
		포인터 변수 앞에*
		포인터가 저장하고 있는 메모리 위치로 가서 거기에 저장된 값에 접근함
		실제 데이터에 간접적(한 단계 거쳐서)으로 접근
			따라서 간접(indirect) 연산자라고도 함
	포인터도  함수 반환값으로 사용 가능
		댕글링 포인터를 조심해야 함
		허용이 되는 경우
			전역 변수, static 전역 변수, 함수 내 static 변수, 힙 메모리에 생성한 데이터
	널 포인터
		아무것도 가리키지 않는 포인터
		아직 참조할 주소가 없고 포인터 변수를 초기화하고 싶을 때 사용
			아무것도 가리키지 않는 포인터 변수를 역 참조하면 결과가 정의되지 않음
		값이 '0'인 정수 상수 표현식, 혹은 void*로 캐스팅된 표현식
		전용 매크로가 있음
			#define NULL ((void*)0)
		0보다는 NULL을 사용하는게 좋음
		포인터와 NULL은 비교 가능
		기본적으로 NULL이 안 들어온다고 가정하고 함수를 작성할 것
		NULL이 들어올 수 있는 함수는 매개변수명에서 분명히 밝힐 것('_or_null')
		NULL포인터를 반환할 수 있는 함수면 함수 이름 끝에 '_or_null'을 붙인다
	포인터의 크기
		포인터는 동일한 크기를 가짐
		포인터 크기는 코드를 컴파일하는 시스템 아키텍쳐에 따라 결정(64비트 = 8비트, 32비트 = 4비트 ···)
	포인터에 정수를 더하고 빼는것은 자료형의 크기만큼 더하고 빼는 것
		int* ptr = nums + 3; 과 int* ptr = &nums[3]; 이 같다는 것
		포인터는 산술 연산이나 배열 첨자 연산자나 동일하게 적용 됨
	두 주소 간의 사칙연산은 뺄샘을 제외하고 모두 지원 안 함
	const 포인터
		int* const ptr = &num;
			메모리 주소를 변경하는 것을 금지
		const int* ptr = &num;
			메모리 주소에 저장되어 있는 값을 변경하는 것을 금지
		const int* const ptr = &num;
			주소, 값 모두 변경하는 것을 금지
		+캐스팅으로 const 제거하는건 절대 하지 말 것
	포인터 배열도 가능함