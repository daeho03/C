입력
	출력의 반대
	외부의 데이터를 읽어와서 프로그램에서 사용
	어떤 데이터가 들어올지 모름
		사용자가 잘못된 데이터를 입력
		예전에 저장해 놓은 파일을 잘못 바꾸거나 유실
	스트림
		콘솔 창에 출력(저장)했으니 콘솔로 부터 입력받아옴
		파일에 출력(저장)했으니 파일로부터 입력받아옴
	문자열
		문자열에 출력(저장)했으니 문자열로부터 입력받아(읽어) 옴
	크게 4가지의 전략이 있음
		한 글자씩 읽기
		한 줄씩 읽기
		한 데이터씩 읽기
		한 블록씩 읽기(이진 데이터)
	한 글자씩 읽기
		한 글자(char)를 읽어오고 필요한 곳에 사용하고 처음으로 돌아가는 방식
			#include <stdio.h>
			int c;
			while (TRUE) {		#define TRUE (1)
				c = getchar();
				putchar(c);
			}
				1. getchar() 함수가 아직 반환 안 함
				2. 키보드로 글자 입력 후 엔터키 누름
				3. 버퍼로부터 한 글자를 읽어옴
				4. 읽은 문자를 출력
				5. 버퍼에 문자가 남아있으므로 3으로 돌아감
		int getchar(void);
			입력의 끝을 나타내는 값, 'EOF'
				EOF는 C 표준에 의하면 음수
				char은 부호가 있을수도 없을수도 있음
				따라서 char에 언제나 'EOF'를 담는것이 불가
`				이게 getchar()가 int를 반환하는 이유
				ctrl키와 다른 키를 조합해서 넣음
					윈도우 환경 : ctrl + z
					리눅스 환경 : ctrl + d
			키보드(stdin)으로부터 문자 하나를 읽음
			반환값
				성공 시, 읽은 문자(의 아스키코드)를 반환
				실패 시, EOF를 반환
			fgetc(stdin)하고 같음
		int c;
		while((c = getchar()) != EOF){
			putchar(c);
		}
			이렇게 줄일 수 있음
			연산자 우선순위때문에 c = getchar()를 괄호로 감싸줘야 함
	한 줄씩 읽기
		gets()는 위험하니 안쓰는게 좋음 C11부터는 없어짐
		fgets()
			최대 count -1개의 문자열을 읽어서 str에 저장
			즉, 새 줄을 만나지 않아도 이 함수가 반환될 수 있음
			str에 새 줄 문자까지  넣어줌
			gets()와 동일
				성공 시, str을 반환
				실패 시, NULL을 반환