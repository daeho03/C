빌드 단계 기본 문법

함수
	C는 접근 제어자(public, private 등)가 없음
	함수 오버로딩이 없음(함수명은 같은데 매개변수가 다른거)
	컴파일러가 함수를 읽기전에 메인에서 실행하면 함수는 int형을 반환해야한다. *매개변수는 상관없음
		함수 원형만 미리 선언해서 해결할 수 있음(전방 선언, 파일 제일 위에 혹은 헤더파일)
			함수 원형에 필요한 것들 : 함수의 이름, 반환형, 매개변수들의 자료형
			best practice
				C99 표준부터는 반환형을 int로 가정하지 않기 때문에 함수 전방선언을 해줘야 함
매개변수의 평가순서
	한줄에 있는 함수 호출 순서에 의존해서 코드를 작성하지 말고 함수 수에 맞게 ;으로 나눠서 따로 호출해야 함
	함수 매개변수의 평가 순서는 컴파일러마다 다를 수 있음
		기본적으로 한 줄에서 동일한 변수를 여러번 바꾸면 위험
			+ 가독성도 안 좋은 코드니 한 표현식에서 같은 변수를 여러번 바꾸지 말 것
	연산자 우선순위와 평가순서도 아무 관련이 없다(시퀀스 포인트가 아님)
		ex) int result = add(num1, num2) + subtract(num1, num2) * divide(num1, num2);
	논리연산자
		int i = 0;
		int j = 0;
		int k = 0;
		if(++i || ++j && ++k){
			printf("true"};
		}
		||, && 등은 시퀀스 포인트이고 평가순서에 따라 묶으면
			if(++i  || (++j && ++k) ... 인데 i에서 참이고 ||이기 때문에 오른쪽 은 건너뛰게 됨(short circuit)
		즉, 논리 연산자의 경우 왼쪽 피연산자를 먼저 실행하고 왼쪽 피연산자의 평가만으로 오른쪽 피연산자를 평가 안 할수도 있음
	한줄에 있는 피연산자들은 기본적으로 평가순서가 보장 안된다고 생각하고
	논리 연산자, 삼항 연산자(if/else, ? :), ;은 평가 순서 보장 됨
const
	c에서는 const를 지원한다
	매개변수로 가져오면서 const를 붙여줄 수 있음
	best practice
		기본적으로 모든 변수에 const를 붙이고 값 변경이 필요한 변수에만 const를 생략하면 좋음
goto
	ex)
		goto <label_name>;
		...
		<label_name>:
	반복문은 결국 goto를 사용하는 코드
	반복문이 goto보다 안전한 방법이여서 goto는 자주 쓰이지 않음
	best practice
		goto문은 언제나 아래쪽으로만 점프
		한 함수 안에 있는 여러 개의 조건문이 공통된 코드를 실행해야 할 때도 써도 됨

스택 메모리
	각 함수에서 사용하는 지역 변수 등을 임시적으로 저장하는 공간
	스택 메모리의 크기는 프로그램 빌드 시에 결정됨
	스택 메모리의 위치는 실행 시에 결정됨
	기본 자료형 변수는 스택 메모리에 할당됨
	기본 자료형을 함수 매개변수로 전달하면 스택에 복사본을 만듦 <- 값형
	new로 만든 데이터는 힙 메모리에 할당됨(스택과 다르게 구멍이 생길 수 있음)
	큰 주소에서 작은 주소로 쌓임
	ESP(Extended Stack Pointer) : 현재 스택 포인터
	EBP(Extended Base Pointer) : 현재 스택 프레임의 기본 주소
	eax : 반환값 저장
	스택 프레임(stack frame) : 각 함수가 사용하는 스택 메모리의 범위
	스택의 크기는 한정적이고 타겟 플랫폼에 따라 달라짐
	프로그래머가 컴파일 시 스택의 크기를 정해줄 수 있음
	clang windows 에서는 대략 1mb
	배열도 스택 메모리에 들어감
	소유하지 않은 메모리에 데이타를 저장하면 문제 생기니 너무 큰 데이터는 스택에 넣을 수 없음
		동적 메모리 할당해야 함
	재귀 함수도 너무 깊게 호출하면 스택 오버플로가 날 수 있음
	sizeof()가 매개변수로 들어온 배열의 총 바이트 수를 반환할려면 배열의 모든 요소가 스택에 복사되어 전달돼야함
		함수의 스택 메모리 사용량은 고정 따라서 배열을 매개변수로 전달할 때는 모든 요소를 스택에 넣지 않고
		그 배열의 시작 위치(주소)를 스택에 넣어 줌 그래서 주소의 크기는 포인터 데이터형의 크기(32비트 플랫폼 : 4바이트, 64비트 플랫폼 : 8바이트)
			매개변수로 들어온 배열의 바이트 수는 4바이트로 반환됨
			배열을 매개변수로 전달하면 배열을 복사 하는것이 아니라 주소를 복사하는거기 때문에 함수에서 배열의 요소를 바꾸면 원본 배열도 바뀜
				따라서 매개변수로 들어온 배열의 길이를 알 방법이 없기 때문에 따로 매개변수로 받아오거나 매크로를 사용해야함
배열
	C는 배열의 요소의 값을 초기화해주지 않음(변수도)
	배열의 모든 값을 초기화 할려면 int nums[10] = {0, };로 써주면 됨
	c, c++은 초기화 안된 지역 변수를 모른 채 사용할 수 있음, 버퍼 오버플로우도 가능하다는 뜻