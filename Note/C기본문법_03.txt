C 프로그램의 빌드 과정
	빌드 : 소스코드를 기계어 명령어로 변환하는 과정, 그리고 그 명령어들을 모아 기계에서 실행 가능한 실행파일로 만드는 과정
	빌드 단계 : 1. 전처리, 2. 컴파일, 3. 어셈블, 4. 링크
		4단계로 나뉘어져 있고, 1 ~ 3을 컴파일이라고도 부르고 있음
	보통 clang -std=c89 -W -Wall -pedantic-errors *.c 처럼 빌드를 함
		clang이 알아서 4단계를 실행 해준 것
		한 단계씩 실행도 가능
	오브젝트 파일을 따로 만들어서 합쳐서 실행파일로 바꾸는게 좋음
C파일
	실제 프로그램을 돌게 하는 로직 코드를 저장해 두는 파일
	내용물
		함수 정의, 매크로, 전역 변수 등
헤더 파일(.h)
	여러 소스코드 파일에 공통적으로 필요한 것들을 저장해 두는 파일
	내용물
		함수 선언(원형), 매크로, extern 변수 선언 등
	#include로 포함함
		ex) #include "···.h"
	함수 선언만 가지고도 컴파일은 가능함.
		실제 올바른 기능 호출은 링크 단계가 책임진다.
			빌드가 여러 단계로 쪼개져 있는 이유가 바로 정의 없이 선언만 가지고도 컴파일이 되게 하기 위해서임
#include	<>, #include ""
	<>는 시스템 경로에서만 헤더 파일을 검색
		보통 컴파일러가 제공하는 시스템 헤더 파일을 include할 때 사용
	""는 현재 작업 중인 디렉터리에서 헤더 파일을 먼저 검색한 뒤 없으면 시스템 경로를 검색
		보통 개발자가 구현한 헤더 파일을 include할 때 사용
전처리 단계
	보통 전처리기라는 별도의 프로그램이 담당
	1. 파일을 받아서 주석을 제거
	2. 매크로를 확장함
	3. include 파일들을 확장함
		#include "헤더 파일"을 지우고 그 자리에 헤더 파일 속에 있는 내용을 복사해다가 가져다 붙이는 것
	4.출력
		확장된 소스코드, translation unit
컴파일 단계
	컴파일러라는 프로그램이 담당
	1. translation unit입력
	2.출력
		어셈블리어 코드
			어셈블리어 코드는  기계코드와  거의 1:1로 대응
				그러나 텍스트 파일이기 때문에 여전히 읽기 쉬운 언어
			어셈블리어 코드는 아직 정의를 모르는 심볼을 사용할 수 있음
				심볼(symbol) : 함수나 변수의 이름 등
	함수나 변수의 주소는 구멍으로 남겨놓고 나중에 링크 단계에서 그 구멍을 메꿈
	어셈블리어 코드가 나온 뒤 부터는 특정 플랫폼에서만 동작(크기가 정해져서)
어셈블 단계
	어셈블러라는 프로그램이 담당
	1. 어셈블리어 코드 입력
	2. 출력
		오브젝트 코드
			기계가 바로 이해 가능한 기계코드
				기계어라고도 한다
			이진코드
			어셈블리어 코드와 마찬가지로 여전히 메꿔야 하는 구멍이 있음
			16진수 편집기로 볼 수 있음
분할 컴파일
	2개이상의 ···.c 파일을 개별적으로 컴파일해서 오브젝트 파일을 만들고 링크해서 실행파일을 만드는 것
링크 단계
	링커라는 프로그램이 담당
	1. 모든 오브젝트 코드 입력
	2. 모든 오브젝트 코드를 모아서 구멍을 메꿈
		함수의 위치를 기억하고 있다가 함수를  호출하려는 코드를 만나면 실행위치에 저장 해둔 위치(주소)로 점프하는 코드를 넣어줌
			오브젝트 코드에서 정의를 못 찾았다면 링커 오류를 뱉음
	4. 출력
		최종 실행파일(···.exe, ···.out)
extern
	다른 파일에 있는 전역 변수에 접근하려고 사용하는 키워드
	헤더에 넣는 것과 c파일에 넣는 방법이 있음
	함수는 보통 extern키워드를 안 쓰고 헤더 파일에 함수 원형을 넣는 방법을 많이 씀
static
	extern을 사용해서 아무데서나 다 전역변수를 사용할 수 있기 때문에 내 파일 안에서만 사용하기 위해 붙이는 키워드
	함수 안에서 선언하면 그 함수 안에서만 접근 가능한 개념상 전역 변수
		즉, 함수가 반환돼도 여전히 값은 저장되어있음
	함수 앞에 static 키워드를 넣으면 외부로부터의 접근을 막을 수 있음
.c 와 .h 파일 정리
	헤더 파일에는 선언만 들어간다
		함수 선언
		전역 변수 extern 선언
	···.c 파일에는 정의가 들어간다
		함수 정의
		전역 및 정적 변수 정의
순환 헤더 인클루드 해결법
	#include는 가능하면 ···.c 에서만 하기
	b헤더에서 a헤더를 인클루드 하는 대신 a에 정의된 것을 전방 선언하는 방법
	인클루드 가드
		#ifndef A		만약 A가 정의되지 않았다면
		#define A		A를 정의할 것
		/* 원래 헤더 파일 내용 */
		#endif /* A */	ifndef 블록의 끝
C 컴파일러들 : GCC
	C는 어느 한 회사가 주도하는 표준이 아니기에 컴파일러도 다양한 회사에서 나옴
	GCC(GNU 컴파일러 모음, GNU Compiler Collection)
		GNU C 컴파일러는 1987년에 첫 출시
		리눅스/유닉스 기반 플랫폼에서 주로 사용되던 컴파일러
		다양한 C표준을 대부분 제대로 지원
	마이크로소프트 Visual C++
		원래 비주얼 스튜디오에 딸려오는 C++컴파일러이지만 확장자가 .c일 경우 C로 컴파일
		C99 표준(그러나 모든 표준을 지키지는 않음)
		C11의 대부분을 지원하지 않음
		윈도우 기반 플랫폼에서 주로 사용
	Clang
		LLVM 컴파일러 구조를 사용하는 C계열 언어(C++, Objective-C/C++, OpenCL, CUDA 등) 컴파일러 프론트엔드
		원래 애플 사가 개발했음
			2007년에 오픈소스로 된 뒤 마이크로소프트, 구글 등 다양한 대기업들이 개발에 참여
		gcc 컴파일러 대신 Clang을 쓰면 코드 변경 거의 없이 그대로 컴파일되고 빠른 컴파일 속도와 LLVM구조가 제공하는 유용한 기능덕에
			많은 gcc사용자들이 Clang으로 이주 중
		clang-ci라는 비주얼 C와 호환되는 프론트엔드도 제공
	기타 소형기기 전용 컴파일러도 많이 있음